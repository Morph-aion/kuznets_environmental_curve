{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Annexe D : Validation du modèle\"\n",
        "execute:\n",
        "  cache: false\n",
        "---"
      ],
      "id": "019e2f3d"
    },
    {
      "cell_type": "code",
      "metadata": {
        "cache": false
      },
      "source": [
        "#| label: setup\n",
        "#| output: false\n",
        "\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "import statsmodels.api as sm\n",
        "import statsmodels.formula.api as smf\n",
        "from statsmodels.tsa.stattools import adfuller\n",
        "from statsmodels.stats.diagnostic import het_breuschpagan, acorr_ljungbox\n",
        "from statsmodels.stats.outliers_influence import variance_inflation_factor\n",
        "from statsmodels.stats.stattools import durbin_watson\n",
        "from sklearn.model_selection import KFold\n",
        "from sklearn.metrics import mean_squared_error\n",
        "from scipy import stats\n",
        "from IPython.display import Markdown, display\n",
        "\n",
        "# Configuration graphique\n",
        "sns.set_theme(style=\"whitegrid\", context=\"paper\", palette=\"colorblind\")\n",
        "plt.rcParams['figure.figsize'] = (10, 6)\n",
        "plt.rcParams['font.size'] = 11\n",
        "\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "# CHARGEMENT ET PRÉPARATION DES DONNÉES\n",
        "# ═══════════════════════════════════════════════════════════════════\n",
        "\n",
        "DATA_LOADED = False\n",
        "\n",
        "try:\n",
        "    df = pd.read_csv(\"../../data/01_raw/kuznets_data_final.csv\")\n",
        "    DATA_LOADED = True\n",
        "    \n",
        "    # ─────────────────────────────────────────────────────────────────\n",
        "    # DONNÉES TRANSVERSALES\n",
        "    # ─────────────────────────────────────────────────────────────────\n",
        "    \n",
        "    ANNEE_CROSS = int(df['year'].max())\n",
        "    df_cross = df[df['year'] == ANNEE_CROSS].copy()\n",
        "    \n",
        "    # Exclusions (micro-États et paradis fiscaux)\n",
        "    # Justification : Micro-États (<500k hab) et paradis fiscaux \n",
        "    # ont une structure économique atypique (PIB/hab artificiellement gonflé)\n",
        "    EXCLUSIONS = [\n",
        "        'Liechtenstein', 'Monaco', 'San Marino', 'Andorra',  # Micro-États\n",
        "        'Luxembourg', 'Ireland', 'Singapore', 'Malta', 'Cyprus',  # Hubs financiers\n",
        "        'Palau', 'Nauru', 'Tuvalu', 'Vatican'  # Micro-États insulaires\n",
        "    ]\n",
        "    \n",
        "    # Nettoyage    \n",
        "    df_cross = df_cross[~df_cross['country'].isin(EXCLUSIONS)]\n",
        "    df_cross = df_cross.dropna(subset=['gdp_per_capita', 'co2_per_capita'])\n",
        "    \n",
        "    # Transformations log\n",
        "    df_cross['log_gdp'] = np.log(df_cross['gdp_per_capita'])\n",
        "    df_cross['log_co2'] = np.log(df_cross['co2_per_capita'])\n",
        "\n",
        "    # Création d'un alias pratique pour l'affichage plus tard\n",
        "    # (S'assure qu'on utilise bien la colonne divisée par la population)    \n",
        "    df_cross['gdp_pc'] = df_cross['gdp_per_capita']\n",
        "    \n",
        "    # Centrage pour réduire multicolinéarité polynomiale\n",
        "    GDP_MEAN = df_cross['log_gdp'].mean()\n",
        "    df_cross['log_gdp_c'] = df_cross['log_gdp'] - GDP_MEAN\n",
        "    \n",
        "    N_PAYS_EXCLUS = len(EXCLUSIONS)\n",
        "    N_PAYS = len(df_cross)\n",
        "    \n",
        "    # ─────────────────────────────────────────────────────────────────\n",
        "    # DONNÉES TEMPORELLES (USA)\n",
        "    # ─────────────────────────────────────────────────────────────────\n",
        "    \n",
        "    df_usa = df[df['country'] == 'United States'].sort_values('year').copy()\n",
        "    \n",
        "    if not df_usa.empty:\n",
        "        # Donnée brute disponible dès 1990\n",
        "        ANNEE_DEBUT_DATA = int(df_usa['year'].min())  # 1990\n",
        "\n",
        "        # Transformations log      \n",
        "        df_usa['log_co2'] = np.log(df_usa['co2_per_capita'])\n",
        "        df_usa['log_gdp'] = np.log(df_usa['gdp_per_capita'])\n",
        "        \n",
        "        # Création d'un alias pratique pour l'affichage plus tard\n",
        "        df_usa['gdp_pc'] = df_usa['gdp_per_capita']\n",
        "\n",
        "        # Centrage USA, Moyenne calculée AVANT dropna pour cohérence\n",
        "        GDP_MEAN_USA = df_usa['log_gdp'].mean()\n",
        "        df_usa['log_gdp_c'] = df_usa['log_gdp'] - GDP_MEAN_USA\n",
        "\n",
        "        # Création des lags (APRÈS centrage)\n",
        "        df_usa['lag_log_co2'] = df_usa['log_co2'].shift(1)\n",
        "        df_usa['lag_log_gdp_c'] = df_usa['log_gdp_c'].shift(1) \n",
        "        \n",
        "        # Nettoyage : enlève la première observation (1990) car lag = NaN\n",
        "        df_usa = df_usa.dropna()\n",
        "\n",
        "        # Estimation démarre en 1991 (après création du lag)\n",
        "        ANNEE_DEBUT_ESTIM = int(df_usa['year'].min())  # 1991\n",
        "        ANNEE_FIN = int(df_usa['year'].max())          # 2020\n",
        "        N_OBS_USA = len(df_usa)                        # 30 observations\n",
        "    else:\n",
        "        N_OBS_USA = ANNEE_DEBUT = ANNEE_FIN = 0\n",
        "\n",
        "except FileNotFoundError:\n",
        "    print(\"⚠️ ERREUR : Fichier data/01_raw/kuznets_data_final.csv introuvable.\")\n",
        "    print(\"   Vérifiez le chemin relatif depuis le répertoire du notebook.\")\n",
        "    df_cross = pd.DataFrame()\n",
        "    df_usa = pd.DataFrame()\n",
        "    N_PAYS = N_PAYS_EXCLUS = N_OBS_USA = 0\n",
        "    ANNEE_DEBUT_DATA = ANNEE_DEBUT_ESTIM = ANNEE_FIN = ANNEE_CROSS = 0\n",
        "    GDP_MEAN = GDP_MEAN_USA = 0\n",
        "\n",
        "except ValueError as e:\n",
        "    print(f\"⚠️ ERREUR DE DONNÉES : {e}\")\n",
        "    print(\"   Causes possibles : valeurs négatives dans PIB ou CO₂, types incorrects.\")\n",
        "    df_cross = pd.DataFrame()\n",
        "    df_usa = pd.DataFrame()\n",
        "    N_PAYS = N_PAYS_EXCLUS = N_OBS_USA = 0\n",
        "    ANNEE_DEBUT_DATA = ANNEE_DEBUT_ESTIM = ANNEE_FIN = ANNEE_CROSS = 0\n",
        "    GDP_MEAN = GDP_MEAN_USA = 0\n",
        "\n",
        "except Exception as e:\n",
        "    print(f\"⚠️ ERREUR INATTENDUE : {e}\")\n",
        "    import traceback\n",
        "    traceback.print_exc()\n",
        "    df_cross = pd.DataFrame()\n",
        "    df_usa = pd.DataFrame()\n",
        "    N_PAYS = N_PAYS_EXCLUS = N_OBS_USA = 0\n",
        "    ANNEE_DEBUT_DATA = ANNEE_DEBUT_ESTIM = ANNEE_FIN = ANNEE_CROSS = 0\n",
        "    GDP_MEAN = GDP_MEAN_USA = 0"
      ],
      "id": "setup",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Validation de la spécification log-log {#sec-box-cox}\n",
        "\n",
        "Le choix d'une transformation logarithmique pour la variable dépendante ($\\text{CO}_2/\\text{hab}$)\n",
        "n'est pas arbitraire. Le **test de Box-Cox** détermine empiriquement la \n",
        "transformation optimale en estimant le paramètre $\\lambda$ :\n",
        "\n",
        "$$Y^{(\\lambda)} = \\begin{cases} \\frac{Y^\\lambda - 1}{\\lambda} & \\text{si } \\lambda \\neq 0 \\\\ \\ln(Y) & \\text{si } \\lambda = 0 \\end{cases}$$"
      ],
      "id": "5039e17e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: test-box-cox\n",
        "#| echo: false\n",
        "\n",
        "if DATA_LOADED and not df_cross.empty:\n",
        "    from scipy import stats as sp_stats\n",
        "    \n",
        "    # Box-Cox sur CO2 per capita\n",
        "    _, lambda_optimal = sp_stats.boxcox(df_cross['co2_per_capita'])\n",
        "    \n",
        "    distance_log = abs(lambda_optimal - 0)\n",
        "    distance_lin = abs(lambda_optimal - 1)\n",
        "    \n",
        "    if distance_log < 0.3:\n",
        "        verdict = \"Fortement justifiée\"\n",
        "    elif distance_log < distance_lin:\n",
        "        verdict = \"Justifiée\"\n",
        "    else:\n",
        "        verdict = \"Alternative à considérer\"\n",
        "    \n",
        "    display(Markdown(f\"\"\"\n",
        "**Résultats du test de Box-Cox**\n",
        "\n",
        "| Paramètre | Valeur |\n",
        "|-----------|--------|\n",
        "| $\\lambda$ optimal estimé | {lambda_optimal:.2f} |\n",
        "| Distance à log ($\\lambda=0$) | {distance_log:.2f} |\n",
        "| Distance à linéaire ($\\lambda=1$) | {distance_lin:.2f} |\n",
        "| **Verdict** | {verdict} |\n",
        "\n",
        "**Interprétation** : \n",
        "\n",
        "- $\\lambda = 0$ → transformation logarithmique optimale\n",
        "- $\\lambda = 1$ → aucune transformation (modèle linéaire)\n",
        "- $\\lambda = 0.5$ → transformation racine carrée\n",
        "\n",
        "Avec $\\lambda = {lambda_optimal:.3f}$, la transformation logarithmique est \n",
        "{'parfaitement' if distance_log < 0.1 else 'raisonnablement'} adaptée \n",
        "à nos données. Ce résultat valide le choix de spécification log-log \n",
        "standard dans la littérature EKC.\n",
        "\"\"\"))"
      ],
      "id": "test-box-cox",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.callout-note}\n",
        "### Note technique\n",
        "Le test de Box-Cox maximise la vraisemblance du modèle pour différentes \n",
        "valeurs de $\\lambda$. Un $\\lambda$ proche de 0 indique que la log-transformation \n",
        "maximise la normalité des résidus et stabilise la variance.\n",
        ":::\n",
        "\n",
        "## Validation non-paramétrique de la forme fonctionnelle {#sec-lowess}\n",
        "\n",
        "Les modèles polynomiaux (quadratique, cubique) imposent une forme \n",
        "fonctionnelle *a priori*. Pour vérifier que cette hypothèse n'est \n",
        "pas trop restrictive, nous comparons les prédictions paramétriques \n",
        "à une régression **LOWESS** (*Locally Weighted Scatterplot Smoothing*), \n",
        "qui laisse les données \"parler d'elles-mêmes\"."
      ],
      "id": "f81c17d8"
    },
    {
      "cell_type": "code",
      "metadata": {
        "fig-width": 12,
        "fig-height": 6
      },
      "source": [
        "#| label: fig-check-models-comparisonv\n",
        "#| fig-cap: Modèles paramétriques (Quadratique et Cubique) vs Modèle non-paramétrique (LOWESS)\n",
        "#| warning: false\n",
        "\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import matplotlib.pyplot as plt\n",
        "import statsmodels.formula.api as smf\n",
        "import statsmodels.api as sm\n",
        "\n",
        "if 'df_cross' in locals() and not df_cross.empty:\n",
        "    \n",
        "    # 1. PRÉPARATION\n",
        "    df_sorted = df_cross.sort_values('gdp_pc')\n",
        "    \n",
        "    # Modèles paramétriques\n",
        "    m_quad = smf.ols('log_co2 ~ log_gdp_c + I(log_gdp_c**2)', data=df_sorted).fit()\n",
        "    m_cub = smf.ols('log_co2 ~ log_gdp_c + I(log_gdp_c**2) + I(log_gdp_c**3)', data=df_sorted).fit()\n",
        "    \n",
        "    # Prédictions (Log)\n",
        "    pred_quad_log = m_quad.predict(df_sorted)\n",
        "    pred_cub_log = m_cub.predict(df_sorted)\n",
        "    \n",
        "    # Prédictions (Linéaire)\n",
        "    pred_quad_lin = np.exp(pred_quad_log)\n",
        "    pred_cub_lin = np.exp(pred_cub_log)\n",
        "\n",
        "    # CALCUL EXPLICTE DU LOWESS (Non-Paramétrique)\n",
        "    # frac=0.3 signifie qu'on lisse sur 30% des points locaux\n",
        "    lowess_log = sm.nonparametric.lowess(df_sorted['log_co2'], df_sorted['log_gdp'], frac=0.3)\n",
        "    lowess_lin = sm.nonparametric.lowess(df_sorted['co2_per_capita'], df_sorted['log_gdp'], frac=0.3)\n",
        "\n",
        "    # 2. GRAPHIQUE\n",
        "    fig, axes = plt.subplots(1, 2, figsize=(12, 6))\n",
        "    \n",
        "    # --- GAUCHE : LOG-LOG ---\n",
        "    axes[0].scatter(df_sorted['log_gdp'], df_sorted['log_co2'], alpha=0.3, color='gray', label='Données')\n",
        "    \n",
        "    axes[0].plot(df_sorted['log_gdp'], pred_quad_log, 'g--', linewidth=2, label='Quadratique')\n",
        "    axes[0].plot(df_sorted['log_gdp'], pred_cub_log, 'r-', linewidth=2.5, label='Cubique')\n",
        "    \n",
        "    # Tracé manuel du LOWESS (Colonne 0 = X, Colonne 1 = Y)\n",
        "    axes[0].plot(lowess_log[:, 0], lowess_log[:, 1], 'b:', linewidth=3, label='Non-Paramétrique (LOWESS)')\n",
        "\n",
        "    axes[0].set_title(\"A. Modèles en Log-Log (Théorie)\", fontweight='bold')\n",
        "    axes[0].set_xlabel(\"Log PIB\")\n",
        "    axes[0].set_ylabel(\"Log CO2\")\n",
        "    axes[0].legend()\n",
        "    axes[0].grid(True, alpha=0.3)\n",
        "\n",
        "    # --- DROITE : LOG-LIN ---\n",
        "    axes[1].scatter(df_sorted['log_gdp'], df_sorted['co2_per_capita'], alpha=0.3, color='gray', label='Données')\n",
        "    \n",
        "    axes[1].plot(df_sorted['log_gdp'], pred_quad_lin, 'g--', linewidth=2, label='Quadratique')\n",
        "    axes[1].plot(df_sorted['log_gdp'], pred_cub_lin, 'r-', linewidth=2.5, label='Cubique')\n",
        "    \n",
        "    # Tracé manuel du LOWESS Linéaire\n",
        "    axes[1].plot(lowess_lin[:, 0], lowess_lin[:, 1], 'b:', linewidth=3, label='Non-Paramétrique (LOWESS)')\n",
        "\n",
        "    axes[1].set_title(\"B. Modèles en Tonnes (Réalité)\", fontweight='bold')\n",
        "    axes[1].set_xlabel(\"Log PIB\")\n",
        "    axes[1].set_ylabel(\"CO2 (Tonnes)\")\n",
        "    axes[1].grid(True, alpha=0.3)\n",
        "\n",
        "    plt.tight_layout()\n",
        "    plt.show()\n",
        "\n",
        "else:\n",
        "    print(\"Erreur : df_cross n'est pas chargé.\")"
      ],
      "id": "fig-check-models-comparisonv",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {
        "fig-width": 16,
        "fig-height": 5
      },
      "source": [
        "#| label: fig-quad-vs-cubic-diff\n",
        "#| fig-cap: 'Test visuel du rebond : différence Quadratique vs Cubique'\n",
        "#| warning: false\n",
        "\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import matplotlib.pyplot as plt\n",
        "import statsmodels.formula.api as smf\n",
        "import statsmodels.api as sm\n",
        "\n",
        "if 'df_cross' in locals() and not df_cross.empty:\n",
        "    \n",
        "    df_sorted = df_cross.sort_values('gdp_pc')\n",
        "    \n",
        "    # Modèles\n",
        "    m_quad = smf.ols('log_co2 ~ log_gdp_c + I(log_gdp_c**2)', data=df_sorted).fit()\n",
        "    m_cub = smf.ols('log_co2 ~ log_gdp_c + I(log_gdp_c**2) + I(log_gdp_c**3)', data=df_sorted).fit()\n",
        "    \n",
        "    # Prédictions\n",
        "    pred_quad_log = m_quad.predict(df_sorted)\n",
        "    pred_cub_log = m_cub.predict(df_sorted)\n",
        "    \n",
        "    # Différence pour le zoom\n",
        "    diff = pred_cub_log - pred_quad_log\n",
        "    \n",
        "    # LOWESS\n",
        "    lowess_log = sm.nonparametric.lowess(df_sorted['log_co2'], df_sorted['log_gdp'], frac=0.3)\n",
        "    \n",
        "    # IC 95% Quadratique\n",
        "    predictions = m_quad.get_prediction(df_sorted)\n",
        "    pred_summary = predictions.summary_frame(alpha=0.05)\n",
        "\n",
        "    # GRAPHIQUE 3 PANELS\n",
        "    fig, axes = plt.subplots(1, 3, figsize=(16, 5))\n",
        "    \n",
        "    # ======================\n",
        "    # PANEL A : Superposition\n",
        "    # ======================\n",
        "    axes[0].scatter(df_sorted['log_gdp'], df_sorted['log_co2'], \n",
        "                   alpha=0.25, color='lightgray', s=30, label='Données (n=159)')\n",
        "    \n",
        "    axes[0].fill_between(df_sorted['log_gdp'], \n",
        "                        pred_summary['mean_ci_lower'], \n",
        "                        pred_summary['mean_ci_upper'],\n",
        "                        alpha=0.15, color='blue', label='IC 95%')\n",
        "    \n",
        "    # ORDRE INVERSÉ pour voir la cubique en dessous\n",
        "    axes[0].plot(df_sorted['log_gdp'], pred_cub_log, \n",
        "                'r-', linewidth=4, label='Cubique (dessous)', alpha=0.6, zorder=2)\n",
        "    axes[0].plot(df_sorted['log_gdp'], pred_quad_log, \n",
        "                'b--', linewidth=2.5, label='Quadratique (dessus)', alpha=0.9, zorder=3)\n",
        "    \n",
        "    axes[0].set_title(\"A. Superposition (quasi-parfaite)\", fontweight='bold', fontsize=12)\n",
        "    axes[0].set_xlabel(\"Log PIB (centré)\", fontsize=10)\n",
        "    axes[0].set_ylabel(\"Log CO₂ (t/hab)\", fontsize=10)\n",
        "    axes[0].legend(loc='upper left', fontsize=9, framealpha=0.95)\n",
        "    axes[0].grid(True, alpha=0.3, linestyle='--')\n",
        "    \n",
        "    # ======================\n",
        "    # PANEL B : DIFFÉRENCE\n",
        "    # ======================\n",
        "    axes[1].axhline(0, color='black', linewidth=1, linestyle='--', alpha=0.5, label='Différence nulle')\n",
        "    axes[1].plot(df_sorted['log_gdp'], diff, \n",
        "                'purple', linewidth=3, label='Cubique - Quadratique', alpha=0.8)\n",
        "    axes[1].fill_between(df_sorted['log_gdp'], diff, 0, \n",
        "                        alpha=0.2, color='purple')\n",
        "    \n",
        "    # Zone hauts revenus\n",
        "    axes[1].axvspan(10.8, 11.2, alpha=0.1, color='red', zorder=0)\n",
        "    axes[1].text(11.0, 0.98, 'Zone critique\\n(PIB > $50k)', \n",
        "                ha='center', fontsize=9, color='darkred',\n",
        "                bbox=dict(boxstyle=\"round,pad=0.3\", facecolor=\"yellow\", alpha=0.3))\n",
        "    \n",
        "    axes[1].set_title(\"B. Différence Cubique - Quadratique\", fontweight='bold', fontsize=12)\n",
        "    axes[1].set_xlabel(\"Log PIB (centré)\", fontsize=10)\n",
        "    axes[1].set_ylabel(\"Écart (log CO₂)\", fontsize=10)\n",
        "    axes[1].legend(loc='best', fontsize=9, framealpha=0.95)\n",
        "    axes[1].grid(True, alpha=0.3, linestyle='--')\n",
        "    \n",
        "    # Annotation résultat\n",
        "    max_diff = np.abs(diff).max()\n",
        "    axes[1].text(0.02, 0.98, \n",
        "                f'Écart maximal : {max_diff:.4f}\\n(≈ 0% en pratique)',\n",
        "                transform=axes[1].transAxes, \n",
        "                fontsize=10,\n",
        "                verticalalignment='top',\n",
        "                bbox=dict(boxstyle='round,pad=0.5', facecolor='lightgreen', alpha=0.7))\n",
        "    \n",
        "    # ======================\n",
        "    # PANEL C : Validation LOWESS\n",
        "    # ======================\n",
        "    axes[2].scatter(df_sorted['log_gdp'], df_sorted['log_co2'], \n",
        "                   alpha=0.25, color='lightgray', s=30, label='Données')\n",
        "    \n",
        "    axes[2].plot(df_sorted['log_gdp'], pred_quad_log, \n",
        "                'b-', linewidth=3, label='Quadratique', alpha=0.8)\n",
        "    axes[2].plot(lowess_log[:, 0], lowess_log[:, 1], \n",
        "                'orange', linewidth=2.5, linestyle=':', label='LOWESS', alpha=0.9)\n",
        "    \n",
        "    axes[2].set_title(\"C. Validation non-paramétrique\", fontweight='bold', fontsize=12)\n",
        "    axes[2].set_xlabel(\"Log PIB\", fontsize=10)\n",
        "    axes[2].set_ylabel(\"Log CO₂\", fontsize=10)\n",
        "    axes[2].legend(loc='upper left', fontsize=9, framealpha=0.95)\n",
        "    axes[2].grid(True, alpha=0.3, linestyle='--')\n",
        "\n",
        "    plt.tight_layout()\n",
        "    \n",
        "    plt.subplots_adjust(bottom=0.12)\n",
        "    plt.show()"
      ],
      "id": "fig-quad-vs-cubic-diff",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/devuser/.venv/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}